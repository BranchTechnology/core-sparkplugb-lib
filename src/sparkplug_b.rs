// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `sparkplug_b.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct Payload {
    // message fields
    timestamp: ::std::option::Option<u64>,
    pub metrics: ::protobuf::RepeatedField<Payload_Metric>,
    seq: ::std::option::Option<u64>,
    uuid: ::protobuf::SingularField<::std::string::String>,
    body: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload {
    fn default() -> &'a Payload {
        <Payload as ::protobuf::Message>::default_instance()
    }
}

impl Payload {
    pub fn new() -> Payload {
        ::std::default::Default::default()
    }

    // optional uint64 timestamp = 1;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.Metric metrics = 2;


    pub fn get_metrics(&self) -> &[Payload_Metric] {
        &self.metrics
    }
    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: ::protobuf::RepeatedField<Payload_Metric>) {
        self.metrics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metrics(&mut self) -> &mut ::protobuf::RepeatedField<Payload_Metric> {
        &mut self.metrics
    }

    // Take field
    pub fn take_metrics(&mut self) -> ::protobuf::RepeatedField<Payload_Metric> {
        ::std::mem::replace(&mut self.metrics, ::protobuf::RepeatedField::new())
    }

    // optional uint64 seq = 3;


    pub fn get_seq(&self) -> u64 {
        self.seq.unwrap_or(0)
    }
    pub fn clear_seq(&mut self) {
        self.seq = ::std::option::Option::None;
    }

    pub fn has_seq(&self) -> bool {
        self.seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u64) {
        self.seq = ::std::option::Option::Some(v);
    }

    // optional string uuid = 4;


    pub fn get_uuid(&self) -> &str {
        match self.uuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        if self.uuid.is_none() {
            self.uuid.set_default();
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        self.uuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes body = 5;


    pub fn get_body(&self) -> &[u8] {
        match self.body.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        self.body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Payload {
    fn is_initialized(&self) -> bool {
        for v in &self.metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metrics)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seq = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uuid)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.seq {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.uuid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint64(1, v)?;
        }
        for v in &self.metrics {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.seq {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.uuid.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload {
        Payload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &Payload| { &m.timestamp },
                |m: &mut Payload| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_Metric>>(
                "metrics",
                |m: &Payload| { &m.metrics },
                |m: &mut Payload| { &mut m.metrics },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seq",
                |m: &Payload| { &m.seq },
                |m: &mut Payload| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uuid",
                |m: &Payload| { &m.uuid },
                |m: &mut Payload| { &mut m.uuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "body",
                |m: &Payload| { &m.body },
                |m: &mut Payload| { &mut m.body },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload>(
                "Payload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload {
        static instance: ::protobuf::rt::LazyV2<Payload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload::new)
    }
}

impl ::protobuf::Clear for Payload {
    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.metrics.clear();
        self.seq = ::std::option::Option::None;
        self.uuid.clear();
        self.body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_Template {
    // message fields
    version: ::protobuf::SingularField<::std::string::String>,
    pub metrics: ::protobuf::RepeatedField<Payload_Metric>,
    pub parameters: ::protobuf::RepeatedField<Payload_Template_Parameter>,
    template_ref: ::protobuf::SingularField<::std::string::String>,
    is_definition: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_Template {
    fn default() -> &'a Payload_Template {
        <Payload_Template as ::protobuf::Message>::default_instance()
    }
}

impl Payload_Template {
    pub fn new() -> Payload_Template {
        ::std::default::Default::default()
    }

    // optional string version = 1;


    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.Metric metrics = 2;


    pub fn get_metrics(&self) -> &[Payload_Metric] {
        &self.metrics
    }
    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: ::protobuf::RepeatedField<Payload_Metric>) {
        self.metrics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metrics(&mut self) -> &mut ::protobuf::RepeatedField<Payload_Metric> {
        &mut self.metrics
    }

    // Take field
    pub fn take_metrics(&mut self) -> ::protobuf::RepeatedField<Payload_Metric> {
        ::std::mem::replace(&mut self.metrics, ::protobuf::RepeatedField::new())
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.Template.Parameter parameters = 3;


    pub fn get_parameters(&self) -> &[Payload_Template_Parameter] {
        &self.parameters
    }
    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::protobuf::RepeatedField<Payload_Template_Parameter>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters(&mut self) -> &mut ::protobuf::RepeatedField<Payload_Template_Parameter> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::protobuf::RepeatedField<Payload_Template_Parameter> {
        ::std::mem::replace(&mut self.parameters, ::protobuf::RepeatedField::new())
    }

    // optional string template_ref = 4;


    pub fn get_template_ref(&self) -> &str {
        match self.template_ref.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_template_ref(&mut self) {
        self.template_ref.clear();
    }

    pub fn has_template_ref(&self) -> bool {
        self.template_ref.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_ref(&mut self, v: ::std::string::String) {
        self.template_ref = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_ref(&mut self) -> &mut ::std::string::String {
        if self.template_ref.is_none() {
            self.template_ref.set_default();
        }
        self.template_ref.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_ref(&mut self) -> ::std::string::String {
        self.template_ref.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_definition = 5;


    pub fn get_is_definition(&self) -> bool {
        self.is_definition.unwrap_or(false)
    }
    pub fn clear_is_definition(&mut self) {
        self.is_definition = ::std::option::Option::None;
    }

    pub fn has_is_definition(&self) -> bool {
        self.is_definition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_definition(&mut self, v: bool) {
        self.is_definition = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Payload_Template {
    fn is_initialized(&self) -> bool {
        for v in &self.metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parameters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metrics)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parameters)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.template_ref)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_definition = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.parameters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.template_ref.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.is_definition {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.metrics {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.parameters {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.template_ref.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.is_definition {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_Template {
        Payload_Template::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &Payload_Template| { &m.version },
                |m: &mut Payload_Template| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_Metric>>(
                "metrics",
                |m: &Payload_Template| { &m.metrics },
                |m: &mut Payload_Template| { &mut m.metrics },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_Template_Parameter>>(
                "parameters",
                |m: &Payload_Template| { &m.parameters },
                |m: &mut Payload_Template| { &mut m.parameters },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "template_ref",
                |m: &Payload_Template| { &m.template_ref },
                |m: &mut Payload_Template| { &mut m.template_ref },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_definition",
                |m: &Payload_Template| { &m.is_definition },
                |m: &mut Payload_Template| { &mut m.is_definition },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_Template>(
                "Payload.Template",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_Template {
        static instance: ::protobuf::rt::LazyV2<Payload_Template> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_Template::new)
    }
}

impl ::protobuf::Clear for Payload_Template {
    fn clear(&mut self) {
        self.version.clear();
        self.metrics.clear();
        self.parameters.clear();
        self.template_ref.clear();
        self.is_definition = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_Template {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_Template {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_Template_Parameter {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<u32>,
    // message oneof groups
    pub value: ::std::option::Option<Payload_Template_Parameter_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_Template_Parameter {
    fn default() -> &'a Payload_Template_Parameter {
        <Payload_Template_Parameter as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Payload_Template_Parameter_oneof_value {
    int_value(u32),
    long_value(u64),
    float_value(f32),
    double_value(f64),
    boolean_value(bool),
    string_value(::std::string::String),
    extension_value(Payload_Template_Parameter_ParameterValueExtension),
}

impl Payload_Template_Parameter {
    pub fn new() -> Payload_Template_Parameter {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 type = 2;


    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional uint32 int_value = 3;


    pub fn get_int_value(&self) -> u32 {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::int_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::int_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::int_value(v))
    }

    // optional uint64 long_value = 4;


    pub fn get_long_value(&self) -> u64 {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::long_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_long_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_long_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::long_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_long_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::long_value(v))
    }

    // optional float float_value = 5;


    pub fn get_float_value(&self) -> f32 {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::float_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_float_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::float_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::float_value(v))
    }

    // optional double double_value = 6;


    pub fn get_double_value(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::double_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::double_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::double_value(v))
    }

    // optional bool boolean_value = 7;


    pub fn get_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::boolean_value(v)) => v,
            _ => false,
        }
    }
    pub fn clear_boolean_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::boolean_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::boolean_value(v))
    }

    // optional string string_value = 8;


    pub fn get_string_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional .org.eclipse.tahu.protobuf.Payload.Template.Parameter.ParameterValueExtension extension_value = 9;


    pub fn get_extension_value(&self) -> &Payload_Template_Parameter_ParameterValueExtension {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::extension_value(ref v)) => v,
            _ => <Payload_Template_Parameter_ParameterValueExtension as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_extension_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_extension_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::extension_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_extension_value(&mut self, v: Payload_Template_Parameter_ParameterValueExtension) {
        self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::extension_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_extension_value(&mut self) -> &mut Payload_Template_Parameter_ParameterValueExtension {
        if let ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::extension_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::extension_value(Payload_Template_Parameter_ParameterValueExtension::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::extension_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_extension_value(&mut self) -> Payload_Template_Parameter_ParameterValueExtension {
        if self.has_extension_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::extension_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Payload_Template_Parameter_ParameterValueExtension::new()
        }
    }
}

impl ::protobuf::Message for Payload_Template_Parameter {
    fn is_initialized(&self) -> bool {
        if let Some(Payload_Template_Parameter_oneof_value::extension_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::int_value(is.read_uint32()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::long_value(is.read_uint64()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::float_value(is.read_float()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::double_value(is.read_double()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::boolean_value(is.read_bool()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::string_value(is.read_string()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Template_Parameter_oneof_value::extension_value(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_Template_Parameter_oneof_value::int_value(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_Template_Parameter_oneof_value::long_value(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_Template_Parameter_oneof_value::float_value(v) => {
                    my_size += 5;
                },
                &Payload_Template_Parameter_oneof_value::double_value(v) => {
                    my_size += 9;
                },
                &Payload_Template_Parameter_oneof_value::boolean_value(v) => {
                    my_size += 2;
                },
                &Payload_Template_Parameter_oneof_value::string_value(ref v) => {
                    my_size += ::protobuf::rt::string_size(8, &v);
                },
                &Payload_Template_Parameter_oneof_value::extension_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint32(2, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_Template_Parameter_oneof_value::int_value(v) => {
                    os.write_uint32(3, v)?;
                },
                &Payload_Template_Parameter_oneof_value::long_value(v) => {
                    os.write_uint64(4, v)?;
                },
                &Payload_Template_Parameter_oneof_value::float_value(v) => {
                    os.write_float(5, v)?;
                },
                &Payload_Template_Parameter_oneof_value::double_value(v) => {
                    os.write_double(6, v)?;
                },
                &Payload_Template_Parameter_oneof_value::boolean_value(v) => {
                    os.write_bool(7, v)?;
                },
                &Payload_Template_Parameter_oneof_value::string_value(ref v) => {
                    os.write_string(8, v)?;
                },
                &Payload_Template_Parameter_oneof_value::extension_value(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_Template_Parameter {
        Payload_Template_Parameter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Payload_Template_Parameter| { &m.name },
                |m: &mut Payload_Template_Parameter| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "type",
                |m: &Payload_Template_Parameter| { &m.field_type },
                |m: &mut Payload_Template_Parameter| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "int_value",
                Payload_Template_Parameter::has_int_value,
                Payload_Template_Parameter::get_int_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "long_value",
                Payload_Template_Parameter::has_long_value,
                Payload_Template_Parameter::get_long_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                "float_value",
                Payload_Template_Parameter::has_float_value,
                Payload_Template_Parameter::get_float_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "double_value",
                Payload_Template_Parameter::has_double_value,
                Payload_Template_Parameter::get_double_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "boolean_value",
                Payload_Template_Parameter::has_boolean_value,
                Payload_Template_Parameter::get_boolean_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "string_value",
                Payload_Template_Parameter::has_string_value,
                Payload_Template_Parameter::get_string_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Payload_Template_Parameter_ParameterValueExtension>(
                "extension_value",
                Payload_Template_Parameter::has_extension_value,
                Payload_Template_Parameter::get_extension_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_Template_Parameter>(
                "Payload.Template.Parameter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_Template_Parameter {
        static instance: ::protobuf::rt::LazyV2<Payload_Template_Parameter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_Template_Parameter::new)
    }
}

impl ::protobuf::Clear for Payload_Template_Parameter {
    fn clear(&mut self) {
        self.name.clear();
        self.field_type = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_Template_Parameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_Template_Parameter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_Template_Parameter_ParameterValueExtension {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_Template_Parameter_ParameterValueExtension {
    fn default() -> &'a Payload_Template_Parameter_ParameterValueExtension {
        <Payload_Template_Parameter_ParameterValueExtension as ::protobuf::Message>::default_instance()
    }
}

impl Payload_Template_Parameter_ParameterValueExtension {
    pub fn new() -> Payload_Template_Parameter_ParameterValueExtension {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Payload_Template_Parameter_ParameterValueExtension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_Template_Parameter_ParameterValueExtension {
        Payload_Template_Parameter_ParameterValueExtension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_Template_Parameter_ParameterValueExtension>(
                "Payload.Template.Parameter.ParameterValueExtension",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_Template_Parameter_ParameterValueExtension {
        static instance: ::protobuf::rt::LazyV2<Payload_Template_Parameter_ParameterValueExtension> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_Template_Parameter_ParameterValueExtension::new)
    }
}

impl ::protobuf::Clear for Payload_Template_Parameter_ParameterValueExtension {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_Template_Parameter_ParameterValueExtension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_Template_Parameter_ParameterValueExtension {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_DataSet {
    // message fields
    num_of_columns: ::std::option::Option<u64>,
    pub columns: ::protobuf::RepeatedField<::std::string::String>,
    pub types: ::std::vec::Vec<u32>,
    pub rows: ::protobuf::RepeatedField<Payload_DataSet_Row>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_DataSet {
    fn default() -> &'a Payload_DataSet {
        <Payload_DataSet as ::protobuf::Message>::default_instance()
    }
}

impl Payload_DataSet {
    pub fn new() -> Payload_DataSet {
        ::std::default::Default::default()
    }

    // optional uint64 num_of_columns = 1;


    pub fn get_num_of_columns(&self) -> u64 {
        self.num_of_columns.unwrap_or(0)
    }
    pub fn clear_num_of_columns(&mut self) {
        self.num_of_columns = ::std::option::Option::None;
    }

    pub fn has_num_of_columns(&self) -> bool {
        self.num_of_columns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_of_columns(&mut self, v: u64) {
        self.num_of_columns = ::std::option::Option::Some(v);
    }

    // repeated string columns = 2;


    pub fn get_columns(&self) -> &[::std::string::String] {
        &self.columns
    }
    pub fn clear_columns(&mut self) {
        self.columns.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.columns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.columns
    }

    // Take field
    pub fn take_columns(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.columns, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 types = 3;


    pub fn get_types(&self) -> &[u32] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::std::vec::Vec<u32>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.types, ::std::vec::Vec::new())
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.DataSet.Row rows = 4;


    pub fn get_rows(&self) -> &[Payload_DataSet_Row] {
        &self.rows
    }
    pub fn clear_rows(&mut self) {
        self.rows.clear();
    }

    // Param is passed by value, moved
    pub fn set_rows(&mut self, v: ::protobuf::RepeatedField<Payload_DataSet_Row>) {
        self.rows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rows(&mut self) -> &mut ::protobuf::RepeatedField<Payload_DataSet_Row> {
        &mut self.rows
    }

    // Take field
    pub fn take_rows(&mut self) -> ::protobuf::RepeatedField<Payload_DataSet_Row> {
        ::std::mem::replace(&mut self.rows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Payload_DataSet {
    fn is_initialized(&self) -> bool {
        for v in &self.rows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_of_columns = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.columns)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.types)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.num_of_columns {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.columns {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.types {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.rows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.num_of_columns {
            os.write_uint64(1, v)?;
        }
        for v in &self.columns {
            os.write_string(2, &v)?;
        };
        for v in &self.types {
            os.write_uint32(3, *v)?;
        };
        for v in &self.rows {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_DataSet {
        Payload_DataSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_of_columns",
                |m: &Payload_DataSet| { &m.num_of_columns },
                |m: &mut Payload_DataSet| { &mut m.num_of_columns },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "columns",
                |m: &Payload_DataSet| { &m.columns },
                |m: &mut Payload_DataSet| { &mut m.columns },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "types",
                |m: &Payload_DataSet| { &m.types },
                |m: &mut Payload_DataSet| { &mut m.types },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_DataSet_Row>>(
                "rows",
                |m: &Payload_DataSet| { &m.rows },
                |m: &mut Payload_DataSet| { &mut m.rows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_DataSet>(
                "Payload.DataSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_DataSet {
        static instance: ::protobuf::rt::LazyV2<Payload_DataSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_DataSet::new)
    }
}

impl ::protobuf::Clear for Payload_DataSet {
    fn clear(&mut self) {
        self.num_of_columns = ::std::option::Option::None;
        self.columns.clear();
        self.types.clear();
        self.rows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_DataSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_DataSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_DataSet_DataSetValue {
    // message oneof groups
    pub value: ::std::option::Option<Payload_DataSet_DataSetValue_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_DataSet_DataSetValue {
    fn default() -> &'a Payload_DataSet_DataSetValue {
        <Payload_DataSet_DataSetValue as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Payload_DataSet_DataSetValue_oneof_value {
    int_value(u32),
    long_value(u64),
    float_value(f32),
    double_value(f64),
    boolean_value(bool),
    string_value(::std::string::String),
    extension_value(Payload_DataSet_DataSetValue_DataSetValueExtension),
}

impl Payload_DataSet_DataSetValue {
    pub fn new() -> Payload_DataSet_DataSetValue {
        ::std::default::Default::default()
    }

    // optional uint32 int_value = 1;


    pub fn get_int_value(&self) -> u32 {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::int_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::int_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::int_value(v))
    }

    // optional uint64 long_value = 2;


    pub fn get_long_value(&self) -> u64 {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::long_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_long_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_long_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::long_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_long_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::long_value(v))
    }

    // optional float float_value = 3;


    pub fn get_float_value(&self) -> f32 {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::float_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_float_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::float_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::float_value(v))
    }

    // optional double double_value = 4;


    pub fn get_double_value(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::double_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::double_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::double_value(v))
    }

    // optional bool boolean_value = 5;


    pub fn get_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::boolean_value(v)) => v,
            _ => false,
        }
    }
    pub fn clear_boolean_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::boolean_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::boolean_value(v))
    }

    // optional string string_value = 6;


    pub fn get_string_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional .org.eclipse.tahu.protobuf.Payload.DataSet.DataSetValue.DataSetValueExtension extension_value = 7;


    pub fn get_extension_value(&self) -> &Payload_DataSet_DataSetValue_DataSetValueExtension {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::extension_value(ref v)) => v,
            _ => <Payload_DataSet_DataSetValue_DataSetValueExtension as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_extension_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_extension_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::extension_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_extension_value(&mut self, v: Payload_DataSet_DataSetValue_DataSetValueExtension) {
        self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::extension_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_extension_value(&mut self) -> &mut Payload_DataSet_DataSetValue_DataSetValueExtension {
        if let ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::extension_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::extension_value(Payload_DataSet_DataSetValue_DataSetValueExtension::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::extension_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_extension_value(&mut self) -> Payload_DataSet_DataSetValue_DataSetValueExtension {
        if self.has_extension_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::extension_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Payload_DataSet_DataSetValue_DataSetValueExtension::new()
        }
    }
}

impl ::protobuf::Message for Payload_DataSet_DataSetValue {
    fn is_initialized(&self) -> bool {
        if let Some(Payload_DataSet_DataSetValue_oneof_value::extension_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::int_value(is.read_uint32()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::long_value(is.read_uint64()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::float_value(is.read_float()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::double_value(is.read_double()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::boolean_value(is.read_bool()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::string_value(is.read_string()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_DataSet_DataSetValue_oneof_value::extension_value(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_DataSet_DataSetValue_oneof_value::int_value(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_DataSet_DataSetValue_oneof_value::long_value(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_DataSet_DataSetValue_oneof_value::float_value(v) => {
                    my_size += 5;
                },
                &Payload_DataSet_DataSetValue_oneof_value::double_value(v) => {
                    my_size += 9;
                },
                &Payload_DataSet_DataSetValue_oneof_value::boolean_value(v) => {
                    my_size += 2;
                },
                &Payload_DataSet_DataSetValue_oneof_value::string_value(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
                &Payload_DataSet_DataSetValue_oneof_value::extension_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_DataSet_DataSetValue_oneof_value::int_value(v) => {
                    os.write_uint32(1, v)?;
                },
                &Payload_DataSet_DataSetValue_oneof_value::long_value(v) => {
                    os.write_uint64(2, v)?;
                },
                &Payload_DataSet_DataSetValue_oneof_value::float_value(v) => {
                    os.write_float(3, v)?;
                },
                &Payload_DataSet_DataSetValue_oneof_value::double_value(v) => {
                    os.write_double(4, v)?;
                },
                &Payload_DataSet_DataSetValue_oneof_value::boolean_value(v) => {
                    os.write_bool(5, v)?;
                },
                &Payload_DataSet_DataSetValue_oneof_value::string_value(ref v) => {
                    os.write_string(6, v)?;
                },
                &Payload_DataSet_DataSetValue_oneof_value::extension_value(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_DataSet_DataSetValue {
        Payload_DataSet_DataSetValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "int_value",
                Payload_DataSet_DataSetValue::has_int_value,
                Payload_DataSet_DataSetValue::get_int_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "long_value",
                Payload_DataSet_DataSetValue::has_long_value,
                Payload_DataSet_DataSetValue::get_long_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                "float_value",
                Payload_DataSet_DataSetValue::has_float_value,
                Payload_DataSet_DataSetValue::get_float_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "double_value",
                Payload_DataSet_DataSetValue::has_double_value,
                Payload_DataSet_DataSetValue::get_double_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "boolean_value",
                Payload_DataSet_DataSetValue::has_boolean_value,
                Payload_DataSet_DataSetValue::get_boolean_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "string_value",
                Payload_DataSet_DataSetValue::has_string_value,
                Payload_DataSet_DataSetValue::get_string_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Payload_DataSet_DataSetValue_DataSetValueExtension>(
                "extension_value",
                Payload_DataSet_DataSetValue::has_extension_value,
                Payload_DataSet_DataSetValue::get_extension_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_DataSet_DataSetValue>(
                "Payload.DataSet.DataSetValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_DataSet_DataSetValue {
        static instance: ::protobuf::rt::LazyV2<Payload_DataSet_DataSetValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_DataSet_DataSetValue::new)
    }
}

impl ::protobuf::Clear for Payload_DataSet_DataSetValue {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_DataSet_DataSetValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_DataSet_DataSetValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_DataSet_DataSetValue_DataSetValueExtension {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_DataSet_DataSetValue_DataSetValueExtension {
    fn default() -> &'a Payload_DataSet_DataSetValue_DataSetValueExtension {
        <Payload_DataSet_DataSetValue_DataSetValueExtension as ::protobuf::Message>::default_instance()
    }
}

impl Payload_DataSet_DataSetValue_DataSetValueExtension {
    pub fn new() -> Payload_DataSet_DataSetValue_DataSetValueExtension {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Payload_DataSet_DataSetValue_DataSetValueExtension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_DataSet_DataSetValue_DataSetValueExtension {
        Payload_DataSet_DataSetValue_DataSetValueExtension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_DataSet_DataSetValue_DataSetValueExtension>(
                "Payload.DataSet.DataSetValue.DataSetValueExtension",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_DataSet_DataSetValue_DataSetValueExtension {
        static instance: ::protobuf::rt::LazyV2<Payload_DataSet_DataSetValue_DataSetValueExtension> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_DataSet_DataSetValue_DataSetValueExtension::new)
    }
}

impl ::protobuf::Clear for Payload_DataSet_DataSetValue_DataSetValueExtension {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_DataSet_DataSetValue_DataSetValueExtension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_DataSet_DataSetValue_DataSetValueExtension {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_DataSet_Row {
    // message fields
    pub elements: ::protobuf::RepeatedField<Payload_DataSet_DataSetValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_DataSet_Row {
    fn default() -> &'a Payload_DataSet_Row {
        <Payload_DataSet_Row as ::protobuf::Message>::default_instance()
    }
}

impl Payload_DataSet_Row {
    pub fn new() -> Payload_DataSet_Row {
        ::std::default::Default::default()
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.DataSet.DataSetValue elements = 1;


    pub fn get_elements(&self) -> &[Payload_DataSet_DataSetValue] {
        &self.elements
    }
    pub fn clear_elements(&mut self) {
        self.elements.clear();
    }

    // Param is passed by value, moved
    pub fn set_elements(&mut self, v: ::protobuf::RepeatedField<Payload_DataSet_DataSetValue>) {
        self.elements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_elements(&mut self) -> &mut ::protobuf::RepeatedField<Payload_DataSet_DataSetValue> {
        &mut self.elements
    }

    // Take field
    pub fn take_elements(&mut self) -> ::protobuf::RepeatedField<Payload_DataSet_DataSetValue> {
        ::std::mem::replace(&mut self.elements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Payload_DataSet_Row {
    fn is_initialized(&self) -> bool {
        for v in &self.elements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.elements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.elements {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_DataSet_Row {
        Payload_DataSet_Row::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_DataSet_DataSetValue>>(
                "elements",
                |m: &Payload_DataSet_Row| { &m.elements },
                |m: &mut Payload_DataSet_Row| { &mut m.elements },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_DataSet_Row>(
                "Payload.DataSet.Row",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_DataSet_Row {
        static instance: ::protobuf::rt::LazyV2<Payload_DataSet_Row> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_DataSet_Row::new)
    }
}

impl ::protobuf::Clear for Payload_DataSet_Row {
    fn clear(&mut self) {
        self.elements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_DataSet_Row {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_DataSet_Row {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_PropertyValue {
    // message fields
    field_type: ::std::option::Option<u32>,
    is_null: ::std::option::Option<bool>,
    // message oneof groups
    pub value: ::std::option::Option<Payload_PropertyValue_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_PropertyValue {
    fn default() -> &'a Payload_PropertyValue {
        <Payload_PropertyValue as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Payload_PropertyValue_oneof_value {
    int_value(u32),
    long_value(u64),
    float_value(f32),
    double_value(f64),
    boolean_value(bool),
    string_value(::std::string::String),
    propertyset_value(Payload_PropertySet),
    propertysets_value(Payload_PropertySetList),
    extension_value(Payload_PropertyValue_PropertyValueExtension),
}

impl Payload_PropertyValue {
    pub fn new() -> Payload_PropertyValue {
        ::std::default::Default::default()
    }

    // optional uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional bool is_null = 2;


    pub fn get_is_null(&self) -> bool {
        self.is_null.unwrap_or(false)
    }
    pub fn clear_is_null(&mut self) {
        self.is_null = ::std::option::Option::None;
    }

    pub fn has_is_null(&self) -> bool {
        self.is_null.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_null(&mut self, v: bool) {
        self.is_null = ::std::option::Option::Some(v);
    }

    // optional uint32 int_value = 3;


    pub fn get_int_value(&self) -> u32 {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::int_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::int_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::int_value(v))
    }

    // optional uint64 long_value = 4;


    pub fn get_long_value(&self) -> u64 {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::long_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_long_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_long_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::long_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_long_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::long_value(v))
    }

    // optional float float_value = 5;


    pub fn get_float_value(&self) -> f32 {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::float_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_float_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::float_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::float_value(v))
    }

    // optional double double_value = 6;


    pub fn get_double_value(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::double_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::double_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::double_value(v))
    }

    // optional bool boolean_value = 7;


    pub fn get_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::boolean_value(v)) => v,
            _ => false,
        }
    }
    pub fn clear_boolean_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::boolean_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::boolean_value(v))
    }

    // optional string string_value = 8;


    pub fn get_string_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional .org.eclipse.tahu.protobuf.Payload.PropertySet propertyset_value = 9;


    pub fn get_propertyset_value(&self) -> &Payload_PropertySet {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(ref v)) => v,
            _ => <Payload_PropertySet as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_propertyset_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_propertyset_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_propertyset_value(&mut self, v: Payload_PropertySet) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_propertyset_value(&mut self) -> &mut Payload_PropertySet {
        if let ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(Payload_PropertySet::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_propertyset_value(&mut self) -> Payload_PropertySet {
        if self.has_propertyset_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Payload_PropertySet::new()
        }
    }

    // optional .org.eclipse.tahu.protobuf.Payload.PropertySetList propertysets_value = 10;


    pub fn get_propertysets_value(&self) -> &Payload_PropertySetList {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(ref v)) => v,
            _ => <Payload_PropertySetList as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_propertysets_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_propertysets_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_propertysets_value(&mut self, v: Payload_PropertySetList) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_propertysets_value(&mut self) -> &mut Payload_PropertySetList {
        if let ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(Payload_PropertySetList::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_propertysets_value(&mut self) -> Payload_PropertySetList {
        if self.has_propertysets_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Payload_PropertySetList::new()
        }
    }

    // optional .org.eclipse.tahu.protobuf.Payload.PropertyValue.PropertyValueExtension extension_value = 11;


    pub fn get_extension_value(&self) -> &Payload_PropertyValue_PropertyValueExtension {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::extension_value(ref v)) => v,
            _ => <Payload_PropertyValue_PropertyValueExtension as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_extension_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_extension_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::extension_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_extension_value(&mut self, v: Payload_PropertyValue_PropertyValueExtension) {
        self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::extension_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_extension_value(&mut self) -> &mut Payload_PropertyValue_PropertyValueExtension {
        if let ::std::option::Option::Some(Payload_PropertyValue_oneof_value::extension_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::extension_value(Payload_PropertyValue_PropertyValueExtension::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_PropertyValue_oneof_value::extension_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_extension_value(&mut self) -> Payload_PropertyValue_PropertyValueExtension {
        if self.has_extension_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_PropertyValue_oneof_value::extension_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Payload_PropertyValue_PropertyValueExtension::new()
        }
    }
}

impl ::protobuf::Message for Payload_PropertyValue {
    fn is_initialized(&self) -> bool {
        if let Some(Payload_PropertyValue_oneof_value::propertyset_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Payload_PropertyValue_oneof_value::propertysets_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Payload_PropertyValue_oneof_value::extension_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_null = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::int_value(is.read_uint32()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::long_value(is.read_uint64()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::float_value(is.read_float()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::double_value(is.read_double()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::boolean_value(is.read_bool()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::string_value(is.read_string()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertyset_value(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::propertysets_value(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_PropertyValue_oneof_value::extension_value(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_null {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_PropertyValue_oneof_value::int_value(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_PropertyValue_oneof_value::long_value(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_PropertyValue_oneof_value::float_value(v) => {
                    my_size += 5;
                },
                &Payload_PropertyValue_oneof_value::double_value(v) => {
                    my_size += 9;
                },
                &Payload_PropertyValue_oneof_value::boolean_value(v) => {
                    my_size += 2;
                },
                &Payload_PropertyValue_oneof_value::string_value(ref v) => {
                    my_size += ::protobuf::rt::string_size(8, &v);
                },
                &Payload_PropertyValue_oneof_value::propertyset_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Payload_PropertyValue_oneof_value::propertysets_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Payload_PropertyValue_oneof_value::extension_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.is_null {
            os.write_bool(2, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_PropertyValue_oneof_value::int_value(v) => {
                    os.write_uint32(3, v)?;
                },
                &Payload_PropertyValue_oneof_value::long_value(v) => {
                    os.write_uint64(4, v)?;
                },
                &Payload_PropertyValue_oneof_value::float_value(v) => {
                    os.write_float(5, v)?;
                },
                &Payload_PropertyValue_oneof_value::double_value(v) => {
                    os.write_double(6, v)?;
                },
                &Payload_PropertyValue_oneof_value::boolean_value(v) => {
                    os.write_bool(7, v)?;
                },
                &Payload_PropertyValue_oneof_value::string_value(ref v) => {
                    os.write_string(8, v)?;
                },
                &Payload_PropertyValue_oneof_value::propertyset_value(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Payload_PropertyValue_oneof_value::propertysets_value(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Payload_PropertyValue_oneof_value::extension_value(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_PropertyValue {
        Payload_PropertyValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "type",
                |m: &Payload_PropertyValue| { &m.field_type },
                |m: &mut Payload_PropertyValue| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_null",
                |m: &Payload_PropertyValue| { &m.is_null },
                |m: &mut Payload_PropertyValue| { &mut m.is_null },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "int_value",
                Payload_PropertyValue::has_int_value,
                Payload_PropertyValue::get_int_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "long_value",
                Payload_PropertyValue::has_long_value,
                Payload_PropertyValue::get_long_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                "float_value",
                Payload_PropertyValue::has_float_value,
                Payload_PropertyValue::get_float_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "double_value",
                Payload_PropertyValue::has_double_value,
                Payload_PropertyValue::get_double_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "boolean_value",
                Payload_PropertyValue::has_boolean_value,
                Payload_PropertyValue::get_boolean_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "string_value",
                Payload_PropertyValue::has_string_value,
                Payload_PropertyValue::get_string_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Payload_PropertySet>(
                "propertyset_value",
                Payload_PropertyValue::has_propertyset_value,
                Payload_PropertyValue::get_propertyset_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Payload_PropertySetList>(
                "propertysets_value",
                Payload_PropertyValue::has_propertysets_value,
                Payload_PropertyValue::get_propertysets_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Payload_PropertyValue_PropertyValueExtension>(
                "extension_value",
                Payload_PropertyValue::has_extension_value,
                Payload_PropertyValue::get_extension_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_PropertyValue>(
                "Payload.PropertyValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_PropertyValue {
        static instance: ::protobuf::rt::LazyV2<Payload_PropertyValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_PropertyValue::new)
    }
}

impl ::protobuf::Clear for Payload_PropertyValue {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.is_null = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_PropertyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_PropertyValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_PropertyValue_PropertyValueExtension {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_PropertyValue_PropertyValueExtension {
    fn default() -> &'a Payload_PropertyValue_PropertyValueExtension {
        <Payload_PropertyValue_PropertyValueExtension as ::protobuf::Message>::default_instance()
    }
}

impl Payload_PropertyValue_PropertyValueExtension {
    pub fn new() -> Payload_PropertyValue_PropertyValueExtension {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Payload_PropertyValue_PropertyValueExtension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_PropertyValue_PropertyValueExtension {
        Payload_PropertyValue_PropertyValueExtension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_PropertyValue_PropertyValueExtension>(
                "Payload.PropertyValue.PropertyValueExtension",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_PropertyValue_PropertyValueExtension {
        static instance: ::protobuf::rt::LazyV2<Payload_PropertyValue_PropertyValueExtension> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_PropertyValue_PropertyValueExtension::new)
    }
}

impl ::protobuf::Clear for Payload_PropertyValue_PropertyValueExtension {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_PropertyValue_PropertyValueExtension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_PropertyValue_PropertyValueExtension {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_PropertySet {
    // message fields
    pub keys: ::protobuf::RepeatedField<::std::string::String>,
    pub values: ::protobuf::RepeatedField<Payload_PropertyValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_PropertySet {
    fn default() -> &'a Payload_PropertySet {
        <Payload_PropertySet as ::protobuf::Message>::default_instance()
    }
}

impl Payload_PropertySet {
    pub fn new() -> Payload_PropertySet {
        ::std::default::Default::default()
    }

    // repeated string keys = 1;


    pub fn get_keys(&self) -> &[::std::string::String] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.PropertyValue values = 2;


    pub fn get_values(&self) -> &[Payload_PropertyValue] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<Payload_PropertyValue>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<Payload_PropertyValue> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<Payload_PropertyValue> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Payload_PropertySet {
    fn is_initialized(&self) -> bool {
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.keys)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.keys {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.keys {
            os.write_string(1, &v)?;
        };
        for v in &self.values {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_PropertySet {
        Payload_PropertySet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keys",
                |m: &Payload_PropertySet| { &m.keys },
                |m: &mut Payload_PropertySet| { &mut m.keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_PropertyValue>>(
                "values",
                |m: &Payload_PropertySet| { &m.values },
                |m: &mut Payload_PropertySet| { &mut m.values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_PropertySet>(
                "Payload.PropertySet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_PropertySet {
        static instance: ::protobuf::rt::LazyV2<Payload_PropertySet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_PropertySet::new)
    }
}

impl ::protobuf::Clear for Payload_PropertySet {
    fn clear(&mut self) {
        self.keys.clear();
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_PropertySet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_PropertySet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_PropertySetList {
    // message fields
    pub propertyset: ::protobuf::RepeatedField<Payload_PropertySet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_PropertySetList {
    fn default() -> &'a Payload_PropertySetList {
        <Payload_PropertySetList as ::protobuf::Message>::default_instance()
    }
}

impl Payload_PropertySetList {
    pub fn new() -> Payload_PropertySetList {
        ::std::default::Default::default()
    }

    // repeated .org.eclipse.tahu.protobuf.Payload.PropertySet propertyset = 1;


    pub fn get_propertyset(&self) -> &[Payload_PropertySet] {
        &self.propertyset
    }
    pub fn clear_propertyset(&mut self) {
        self.propertyset.clear();
    }

    // Param is passed by value, moved
    pub fn set_propertyset(&mut self, v: ::protobuf::RepeatedField<Payload_PropertySet>) {
        self.propertyset = v;
    }

    // Mutable pointer to the field.
    pub fn mut_propertyset(&mut self) -> &mut ::protobuf::RepeatedField<Payload_PropertySet> {
        &mut self.propertyset
    }

    // Take field
    pub fn take_propertyset(&mut self) -> ::protobuf::RepeatedField<Payload_PropertySet> {
        ::std::mem::replace(&mut self.propertyset, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Payload_PropertySetList {
    fn is_initialized(&self) -> bool {
        for v in &self.propertyset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.propertyset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.propertyset {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.propertyset {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_PropertySetList {
        Payload_PropertySetList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_PropertySet>>(
                "propertyset",
                |m: &Payload_PropertySetList| { &m.propertyset },
                |m: &mut Payload_PropertySetList| { &mut m.propertyset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_PropertySetList>(
                "Payload.PropertySetList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_PropertySetList {
        static instance: ::protobuf::rt::LazyV2<Payload_PropertySetList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_PropertySetList::new)
    }
}

impl ::protobuf::Clear for Payload_PropertySetList {
    fn clear(&mut self) {
        self.propertyset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_PropertySetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_PropertySetList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_MetaData {
    // message fields
    is_multi_part: ::std::option::Option<bool>,
    content_type: ::protobuf::SingularField<::std::string::String>,
    size: ::std::option::Option<u64>,
    seq: ::std::option::Option<u64>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    file_type: ::protobuf::SingularField<::std::string::String>,
    md5: ::protobuf::SingularField<::std::string::String>,
    description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_MetaData {
    fn default() -> &'a Payload_MetaData {
        <Payload_MetaData as ::protobuf::Message>::default_instance()
    }
}

impl Payload_MetaData {
    pub fn new() -> Payload_MetaData {
        ::std::default::Default::default()
    }

    // optional bool is_multi_part = 1;


    pub fn get_is_multi_part(&self) -> bool {
        self.is_multi_part.unwrap_or(false)
    }
    pub fn clear_is_multi_part(&mut self) {
        self.is_multi_part = ::std::option::Option::None;
    }

    pub fn has_is_multi_part(&self) -> bool {
        self.is_multi_part.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_multi_part(&mut self, v: bool) {
        self.is_multi_part = ::std::option::Option::Some(v);
    }

    // optional string content_type = 2;


    pub fn get_content_type(&self) -> &str {
        match self.content_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_content_type(&mut self) {
        self.content_type.clear();
    }

    pub fn has_content_type(&self) -> bool {
        self.content_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: ::std::string::String) {
        self.content_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content_type(&mut self) -> &mut ::std::string::String {
        if self.content_type.is_none() {
            self.content_type.set_default();
        }
        self.content_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_content_type(&mut self) -> ::std::string::String {
        self.content_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 size = 3;


    pub fn get_size(&self) -> u64 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional uint64 seq = 4;


    pub fn get_seq(&self) -> u64 {
        self.seq.unwrap_or(0)
    }
    pub fn clear_seq(&mut self) {
        self.seq = ::std::option::Option::None;
    }

    pub fn has_seq(&self) -> bool {
        self.seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u64) {
        self.seq = ::std::option::Option::Some(v);
    }

    // optional string file_name = 5;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file_type = 6;


    pub fn get_file_type(&self) -> &str {
        match self.file_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_type(&mut self) {
        self.file_type.clear();
    }

    pub fn has_file_type(&self) -> bool {
        self.file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_type(&mut self, v: ::std::string::String) {
        self.file_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_type(&mut self) -> &mut ::std::string::String {
        if self.file_type.is_none() {
            self.file_type.set_default();
        }
        self.file_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_type(&mut self) -> ::std::string::String {
        self.file_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string md5 = 7;


    pub fn get_md5(&self) -> &str {
        match self.md5.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_md5(&mut self) {
        self.md5.clear();
    }

    pub fn has_md5(&self) -> bool {
        self.md5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_md5(&mut self, v: ::std::string::String) {
        self.md5 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_md5(&mut self) -> &mut ::std::string::String {
        if self.md5.is_none() {
            self.md5.set_default();
        }
        self.md5.as_mut().unwrap()
    }

    // Take field
    pub fn take_md5(&mut self) -> ::std::string::String {
        self.md5.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 8;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Payload_MetaData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_multi_part = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.content_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seq = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_type)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.md5)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_multi_part {
            my_size += 2;
        }
        if let Some(ref v) = self.content_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.file_type.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.md5.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_multi_part {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.content_type.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.seq {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.file_type.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.md5.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_MetaData {
        Payload_MetaData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_multi_part",
                |m: &Payload_MetaData| { &m.is_multi_part },
                |m: &mut Payload_MetaData| { &mut m.is_multi_part },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "content_type",
                |m: &Payload_MetaData| { &m.content_type },
                |m: &mut Payload_MetaData| { &mut m.content_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "size",
                |m: &Payload_MetaData| { &m.size },
                |m: &mut Payload_MetaData| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seq",
                |m: &Payload_MetaData| { &m.seq },
                |m: &mut Payload_MetaData| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &Payload_MetaData| { &m.file_name },
                |m: &mut Payload_MetaData| { &mut m.file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_type",
                |m: &Payload_MetaData| { &m.file_type },
                |m: &mut Payload_MetaData| { &mut m.file_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "md5",
                |m: &Payload_MetaData| { &m.md5 },
                |m: &mut Payload_MetaData| { &mut m.md5 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Payload_MetaData| { &m.description },
                |m: &mut Payload_MetaData| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_MetaData>(
                "Payload.MetaData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_MetaData {
        static instance: ::protobuf::rt::LazyV2<Payload_MetaData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_MetaData::new)
    }
}

impl ::protobuf::Clear for Payload_MetaData {
    fn clear(&mut self) {
        self.is_multi_part = ::std::option::Option::None;
        self.content_type.clear();
        self.size = ::std::option::Option::None;
        self.seq = ::std::option::Option::None;
        self.file_name.clear();
        self.file_type.clear();
        self.md5.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_MetaData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_MetaData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_Metric {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    alias: ::std::option::Option<u64>,
    timestamp: ::std::option::Option<u64>,
    datatype: ::std::option::Option<u32>,
    is_historical: ::std::option::Option<bool>,
    is_transient: ::std::option::Option<bool>,
    is_null: ::std::option::Option<bool>,
    pub metadata: ::protobuf::SingularPtrField<Payload_MetaData>,
    pub properties: ::protobuf::SingularPtrField<Payload_PropertySet>,
    // message oneof groups
    pub value: ::std::option::Option<Payload_Metric_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_Metric {
    fn default() -> &'a Payload_Metric {
        <Payload_Metric as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Payload_Metric_oneof_value {
    int_value(u32),
    long_value(u64),
    float_value(f32),
    double_value(f64),
    boolean_value(bool),
    string_value(::std::string::String),
    bytes_value(::std::vec::Vec<u8>),
    dataset_value(Payload_DataSet),
    template_value(Payload_Template),
    extension_value(Payload_Metric_MetricValueExtension),
}

impl Payload_Metric {
    pub fn new() -> Payload_Metric {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 alias = 2;


    pub fn get_alias(&self) -> u64 {
        self.alias.unwrap_or(0)
    }
    pub fn clear_alias(&mut self) {
        self.alias = ::std::option::Option::None;
    }

    pub fn has_alias(&self) -> bool {
        self.alias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: u64) {
        self.alias = ::std::option::Option::Some(v);
    }

    // optional uint64 timestamp = 3;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 datatype = 4;


    pub fn get_datatype(&self) -> u32 {
        self.datatype.unwrap_or(0)
    }
    pub fn clear_datatype(&mut self) {
        self.datatype = ::std::option::Option::None;
    }

    pub fn has_datatype(&self) -> bool {
        self.datatype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datatype(&mut self, v: u32) {
        self.datatype = ::std::option::Option::Some(v);
    }

    // optional bool is_historical = 5;


    pub fn get_is_historical(&self) -> bool {
        self.is_historical.unwrap_or(false)
    }
    pub fn clear_is_historical(&mut self) {
        self.is_historical = ::std::option::Option::None;
    }

    pub fn has_is_historical(&self) -> bool {
        self.is_historical.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_historical(&mut self, v: bool) {
        self.is_historical = ::std::option::Option::Some(v);
    }

    // optional bool is_transient = 6;


    pub fn get_is_transient(&self) -> bool {
        self.is_transient.unwrap_or(false)
    }
    pub fn clear_is_transient(&mut self) {
        self.is_transient = ::std::option::Option::None;
    }

    pub fn has_is_transient(&self) -> bool {
        self.is_transient.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_transient(&mut self, v: bool) {
        self.is_transient = ::std::option::Option::Some(v);
    }

    // optional bool is_null = 7;


    pub fn get_is_null(&self) -> bool {
        self.is_null.unwrap_or(false)
    }
    pub fn clear_is_null(&mut self) {
        self.is_null = ::std::option::Option::None;
    }

    pub fn has_is_null(&self) -> bool {
        self.is_null.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_null(&mut self, v: bool) {
        self.is_null = ::std::option::Option::Some(v);
    }

    // optional .org.eclipse.tahu.protobuf.Payload.MetaData metadata = 8;


    pub fn get_metadata(&self) -> &Payload_MetaData {
        self.metadata.as_ref().unwrap_or_else(|| <Payload_MetaData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: Payload_MetaData) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut Payload_MetaData {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> Payload_MetaData {
        self.metadata.take().unwrap_or_else(|| Payload_MetaData::new())
    }

    // optional .org.eclipse.tahu.protobuf.Payload.PropertySet properties = 9;


    pub fn get_properties(&self) -> &Payload_PropertySet {
        self.properties.as_ref().unwrap_or_else(|| <Payload_PropertySet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    pub fn has_properties(&self) -> bool {
        self.properties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: Payload_PropertySet) {
        self.properties = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_properties(&mut self) -> &mut Payload_PropertySet {
        if self.properties.is_none() {
            self.properties.set_default();
        }
        self.properties.as_mut().unwrap()
    }

    // Take field
    pub fn take_properties(&mut self) -> Payload_PropertySet {
        self.properties.take().unwrap_or_else(|| Payload_PropertySet::new())
    }

    // optional uint32 int_value = 10;


    pub fn get_int_value(&self) -> u32 {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::int_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::int_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::int_value(v))
    }

    // optional uint64 long_value = 11;


    pub fn get_long_value(&self) -> u64 {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::long_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_long_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_long_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::long_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_long_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::long_value(v))
    }

    // optional float float_value = 12;


    pub fn get_float_value(&self) -> f32 {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::float_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_float_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::float_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::float_value(v))
    }

    // optional double double_value = 13;


    pub fn get_double_value(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::double_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::double_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::double_value(v))
    }

    // optional bool boolean_value = 14;


    pub fn get_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::boolean_value(v)) => v,
            _ => false,
        }
    }
    pub fn clear_boolean_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_boolean_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::boolean_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::boolean_value(v))
    }

    // optional string string_value = 15;


    pub fn get_string_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional bytes bytes_value = 16;


    pub fn get_bytes_value(&self) -> &[u8] {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_bytes_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bytes_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bytes_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bytes_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(::std::vec::Vec::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bytes_value(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_bytes_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // optional .org.eclipse.tahu.protobuf.Payload.DataSet dataset_value = 17;


    pub fn get_dataset_value(&self) -> &Payload_DataSet {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(ref v)) => v,
            _ => <Payload_DataSet as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dataset_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_dataset_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dataset_value(&mut self, v: Payload_DataSet) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dataset_value(&mut self) -> &mut Payload_DataSet {
        if let ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(Payload_DataSet::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dataset_value(&mut self) -> Payload_DataSet {
        if self.has_dataset_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Payload_DataSet::new()
        }
    }

    // optional .org.eclipse.tahu.protobuf.Payload.Template template_value = 18;


    pub fn get_template_value(&self) -> &Payload_Template {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(ref v)) => v,
            _ => <Payload_Template as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_template_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_template_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_template_value(&mut self, v: Payload_Template) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_template_value(&mut self) -> &mut Payload_Template {
        if let ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(Payload_Template::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_template_value(&mut self) -> Payload_Template {
        if self.has_template_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Payload_Template::new()
        }
    }

    // optional .org.eclipse.tahu.protobuf.Payload.Metric.MetricValueExtension extension_value = 19;


    pub fn get_extension_value(&self) -> &Payload_Metric_MetricValueExtension {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::extension_value(ref v)) => v,
            _ => <Payload_Metric_MetricValueExtension as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_extension_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_extension_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::extension_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_extension_value(&mut self, v: Payload_Metric_MetricValueExtension) {
        self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::extension_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_extension_value(&mut self) -> &mut Payload_Metric_MetricValueExtension {
        if let ::std::option::Option::Some(Payload_Metric_oneof_value::extension_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::extension_value(Payload_Metric_MetricValueExtension::new()));
        }
        match self.value {
            ::std::option::Option::Some(Payload_Metric_oneof_value::extension_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_extension_value(&mut self) -> Payload_Metric_MetricValueExtension {
        if self.has_extension_value() {
            match self.value.take() {
                ::std::option::Option::Some(Payload_Metric_oneof_value::extension_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Payload_Metric_MetricValueExtension::new()
        }
    }
}

impl ::protobuf::Message for Payload_Metric {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Payload_Metric_oneof_value::dataset_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Payload_Metric_oneof_value::template_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Payload_Metric_oneof_value::extension_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.alias = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.datatype = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_historical = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_transient = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_null = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.properties)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::int_value(is.read_uint32()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::long_value(is.read_uint64()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::float_value(is.read_float()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::double_value(is.read_double()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::boolean_value(is.read_bool()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::string_value(is.read_string()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::bytes_value(is.read_bytes()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::dataset_value(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::template_value(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Payload_Metric_oneof_value::extension_value(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.alias {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.datatype {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_historical {
            my_size += 2;
        }
        if let Some(v) = self.is_transient {
            my_size += 2;
        }
        if let Some(v) = self.is_null {
            my_size += 2;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.properties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_Metric_oneof_value::int_value(v) => {
                    my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_Metric_oneof_value::long_value(v) => {
                    my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Payload_Metric_oneof_value::float_value(v) => {
                    my_size += 5;
                },
                &Payload_Metric_oneof_value::double_value(v) => {
                    my_size += 9;
                },
                &Payload_Metric_oneof_value::boolean_value(v) => {
                    my_size += 2;
                },
                &Payload_Metric_oneof_value::string_value(ref v) => {
                    my_size += ::protobuf::rt::string_size(15, &v);
                },
                &Payload_Metric_oneof_value::bytes_value(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(16, &v);
                },
                &Payload_Metric_oneof_value::dataset_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Payload_Metric_oneof_value::template_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Payload_Metric_oneof_value::extension_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.alias {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.datatype {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.is_historical {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_transient {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.is_null {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.properties.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Payload_Metric_oneof_value::int_value(v) => {
                    os.write_uint32(10, v)?;
                },
                &Payload_Metric_oneof_value::long_value(v) => {
                    os.write_uint64(11, v)?;
                },
                &Payload_Metric_oneof_value::float_value(v) => {
                    os.write_float(12, v)?;
                },
                &Payload_Metric_oneof_value::double_value(v) => {
                    os.write_double(13, v)?;
                },
                &Payload_Metric_oneof_value::boolean_value(v) => {
                    os.write_bool(14, v)?;
                },
                &Payload_Metric_oneof_value::string_value(ref v) => {
                    os.write_string(15, v)?;
                },
                &Payload_Metric_oneof_value::bytes_value(ref v) => {
                    os.write_bytes(16, v)?;
                },
                &Payload_Metric_oneof_value::dataset_value(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Payload_Metric_oneof_value::template_value(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Payload_Metric_oneof_value::extension_value(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_Metric {
        Payload_Metric::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Payload_Metric| { &m.name },
                |m: &mut Payload_Metric| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "alias",
                |m: &Payload_Metric| { &m.alias },
                |m: &mut Payload_Metric| { &mut m.alias },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &Payload_Metric| { &m.timestamp },
                |m: &mut Payload_Metric| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "datatype",
                |m: &Payload_Metric| { &m.datatype },
                |m: &mut Payload_Metric| { &mut m.datatype },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_historical",
                |m: &Payload_Metric| { &m.is_historical },
                |m: &mut Payload_Metric| { &mut m.is_historical },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_transient",
                |m: &Payload_Metric| { &m.is_transient },
                |m: &mut Payload_Metric| { &mut m.is_transient },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_null",
                |m: &Payload_Metric| { &m.is_null },
                |m: &mut Payload_Metric| { &mut m.is_null },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_MetaData>>(
                "metadata",
                |m: &Payload_Metric| { &m.metadata },
                |m: &mut Payload_Metric| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload_PropertySet>>(
                "properties",
                |m: &Payload_Metric| { &m.properties },
                |m: &mut Payload_Metric| { &mut m.properties },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "int_value",
                Payload_Metric::has_int_value,
                Payload_Metric::get_int_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "long_value",
                Payload_Metric::has_long_value,
                Payload_Metric::get_long_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                "float_value",
                Payload_Metric::has_float_value,
                Payload_Metric::get_float_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "double_value",
                Payload_Metric::has_double_value,
                Payload_Metric::get_double_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "boolean_value",
                Payload_Metric::has_boolean_value,
                Payload_Metric::get_boolean_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "string_value",
                Payload_Metric::has_string_value,
                Payload_Metric::get_string_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "bytes_value",
                Payload_Metric::has_bytes_value,
                Payload_Metric::get_bytes_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Payload_DataSet>(
                "dataset_value",
                Payload_Metric::has_dataset_value,
                Payload_Metric::get_dataset_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Payload_Template>(
                "template_value",
                Payload_Metric::has_template_value,
                Payload_Metric::get_template_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Payload_Metric_MetricValueExtension>(
                "extension_value",
                Payload_Metric::has_extension_value,
                Payload_Metric::get_extension_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_Metric>(
                "Payload.Metric",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_Metric {
        static instance: ::protobuf::rt::LazyV2<Payload_Metric> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_Metric::new)
    }
}

impl ::protobuf::Clear for Payload_Metric {
    fn clear(&mut self) {
        self.name.clear();
        self.alias = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.datatype = ::std::option::Option::None;
        self.is_historical = ::std::option::Option::None;
        self.is_transient = ::std::option::Option::None;
        self.is_null = ::std::option::Option::None;
        self.metadata.clear();
        self.properties.clear();
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_Metric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_Metric {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payload_Metric_MetricValueExtension {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload_Metric_MetricValueExtension {
    fn default() -> &'a Payload_Metric_MetricValueExtension {
        <Payload_Metric_MetricValueExtension as ::protobuf::Message>::default_instance()
    }
}

impl Payload_Metric_MetricValueExtension {
    pub fn new() -> Payload_Metric_MetricValueExtension {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Payload_Metric_MetricValueExtension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload_Metric_MetricValueExtension {
        Payload_Metric_MetricValueExtension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload_Metric_MetricValueExtension>(
                "Payload.Metric.MetricValueExtension",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload_Metric_MetricValueExtension {
        static instance: ::protobuf::rt::LazyV2<Payload_Metric_MetricValueExtension> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload_Metric_MetricValueExtension::new)
    }
}

impl ::protobuf::Clear for Payload_Metric_MetricValueExtension {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload_Metric_MetricValueExtension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload_Metric_MetricValueExtension {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DataType {
    Unknown = 0,
    Int8 = 1,
    Int16 = 2,
    Int32 = 3,
    Int64 = 4,
    UInt8 = 5,
    UInt16 = 6,
    UInt32 = 7,
    UInt64 = 8,
    Float = 9,
    Double = 10,
    Boolean = 11,
    String = 12,
    DateTime = 13,
    Text = 14,
    UUID = 15,
    DataSet = 16,
    Bytes = 17,
    File = 18,
    Template = 19,
    PropertySet = 20,
    PropertySetList = 21,
    Int8Array = 22,
    Int16Array = 23,
    Int32Array = 24,
    Int64Array = 25,
    UInt8Array = 26,
    UInt16Array = 27,
    UInt32Array = 28,
    UInt64Array = 29,
    FloatArray = 30,
    DoubleArray = 31,
    BooleanArray = 32,
    StringArray = 33,
    DateTimeArray = 34,
}

impl ::protobuf::ProtobufEnum for DataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataType> {
        match value {
            0 => ::std::option::Option::Some(DataType::Unknown),
            1 => ::std::option::Option::Some(DataType::Int8),
            2 => ::std::option::Option::Some(DataType::Int16),
            3 => ::std::option::Option::Some(DataType::Int32),
            4 => ::std::option::Option::Some(DataType::Int64),
            5 => ::std::option::Option::Some(DataType::UInt8),
            6 => ::std::option::Option::Some(DataType::UInt16),
            7 => ::std::option::Option::Some(DataType::UInt32),
            8 => ::std::option::Option::Some(DataType::UInt64),
            9 => ::std::option::Option::Some(DataType::Float),
            10 => ::std::option::Option::Some(DataType::Double),
            11 => ::std::option::Option::Some(DataType::Boolean),
            12 => ::std::option::Option::Some(DataType::String),
            13 => ::std::option::Option::Some(DataType::DateTime),
            14 => ::std::option::Option::Some(DataType::Text),
            15 => ::std::option::Option::Some(DataType::UUID),
            16 => ::std::option::Option::Some(DataType::DataSet),
            17 => ::std::option::Option::Some(DataType::Bytes),
            18 => ::std::option::Option::Some(DataType::File),
            19 => ::std::option::Option::Some(DataType::Template),
            20 => ::std::option::Option::Some(DataType::PropertySet),
            21 => ::std::option::Option::Some(DataType::PropertySetList),
            22 => ::std::option::Option::Some(DataType::Int8Array),
            23 => ::std::option::Option::Some(DataType::Int16Array),
            24 => ::std::option::Option::Some(DataType::Int32Array),
            25 => ::std::option::Option::Some(DataType::Int64Array),
            26 => ::std::option::Option::Some(DataType::UInt8Array),
            27 => ::std::option::Option::Some(DataType::UInt16Array),
            28 => ::std::option::Option::Some(DataType::UInt32Array),
            29 => ::std::option::Option::Some(DataType::UInt64Array),
            30 => ::std::option::Option::Some(DataType::FloatArray),
            31 => ::std::option::Option::Some(DataType::DoubleArray),
            32 => ::std::option::Option::Some(DataType::BooleanArray),
            33 => ::std::option::Option::Some(DataType::StringArray),
            34 => ::std::option::Option::Some(DataType::DateTimeArray),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataType] = &[
            DataType::Unknown,
            DataType::Int8,
            DataType::Int16,
            DataType::Int32,
            DataType::Int64,
            DataType::UInt8,
            DataType::UInt16,
            DataType::UInt32,
            DataType::UInt64,
            DataType::Float,
            DataType::Double,
            DataType::Boolean,
            DataType::String,
            DataType::DateTime,
            DataType::Text,
            DataType::UUID,
            DataType::DataSet,
            DataType::Bytes,
            DataType::File,
            DataType::Template,
            DataType::PropertySet,
            DataType::PropertySetList,
            DataType::Int8Array,
            DataType::Int16Array,
            DataType::Int32Array,
            DataType::Int64Array,
            DataType::UInt8Array,
            DataType::UInt16Array,
            DataType::UInt32Array,
            DataType::UInt64Array,
            DataType::FloatArray,
            DataType::DoubleArray,
            DataType::BooleanArray,
            DataType::StringArray,
            DataType::DateTimeArray,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataType>("DataType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataType {
}

impl ::std::default::Default for DataType {
    fn default() -> Self {
        DataType::Unknown
    }
}

impl ::protobuf::reflect::ProtobufValue for DataType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11sparkplug_b.proto\x12\x19org.eclipse.tahu.protobuf\"\x87\x1c\n\x07\
    Payload\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x04R\ttimestamp\x12C\n\x07\
    metrics\x18\x02\x20\x03(\x0b2).org.eclipse.tahu.protobuf.Payload.MetricR\
    \x07metrics\x12\x10\n\x03seq\x18\x03\x20\x01(\x04R\x03seq\x12\x12\n\x04u\
    uid\x18\x04\x20\x01(\tR\x04uuid\x12\x12\n\x04body\x18\x05\x20\x01(\x0cR\
    \x04body\x1a\xc4\x05\n\x08Template\x12\x18\n\x07version\x18\x01\x20\x01(\
    \tR\x07version\x12C\n\x07metrics\x18\x02\x20\x03(\x0b2).org.eclipse.tahu\
    .protobuf.Payload.MetricR\x07metrics\x12U\n\nparameters\x18\x03\x20\x03(\
    \x0b25.org.eclipse.tahu.protobuf.Payload.Template.ParameterR\nparameters\
    \x12!\n\x0ctemplate_ref\x18\x04\x20\x01(\tR\x0btemplateRef\x12#\n\ris_de\
    finition\x18\x05\x20\x01(\x08R\x0cisDefinition\x1a\xaf\x03\n\tParameter\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04type\x18\x02\
    \x20\x01(\rR\x04type\x12\x1d\n\tint_value\x18\x03\x20\x01(\rH\0R\x08intV\
    alue\x12\x1f\n\nlong_value\x18\x04\x20\x01(\x04H\0R\tlongValue\x12!\n\
    \x0bfloat_value\x18\x05\x20\x01(\x02H\0R\nfloatValue\x12#\n\x0cdouble_va\
    lue\x18\x06\x20\x01(\x01H\0R\x0bdoubleValue\x12%\n\rboolean_value\x18\
    \x07\x20\x01(\x08H\0R\x0cbooleanValue\x12#\n\x0cstring_value\x18\x08\x20\
    \x01(\tH\0R\x0bstringValue\x12x\n\x0fextension_value\x18\t\x20\x01(\x0b2\
    M.org.eclipse.tahu.protobuf.Payload.Template.Parameter.ParameterValueExt\
    ensionH\0R\x0eextensionValue\x1a#\n\x17ParameterValueExtension*\x08\x08\
    \x01\x10\x80\x80\x80\x80\x02B\x07\n\x05value*\x08\x08\x06\x10\x80\x80\
    \x80\x80\x02\x1a\x9e\x05\n\x07DataSet\x12$\n\x0enum_of_columns\x18\x01\
    \x20\x01(\x04R\x0cnumOfColumns\x12\x18\n\x07columns\x18\x02\x20\x03(\tR\
    \x07columns\x12\x14\n\x05types\x18\x03\x20\x03(\rR\x05types\x12B\n\x04ro\
    ws\x18\x04\x20\x03(\x0b2..org.eclipse.tahu.protobuf.Payload.DataSet.RowR\
    \x04rows\x1a\x88\x03\n\x0cDataSetValue\x12\x1d\n\tint_value\x18\x01\x20\
    \x01(\rH\0R\x08intValue\x12\x1f\n\nlong_value\x18\x02\x20\x01(\x04H\0R\t\
    longValue\x12!\n\x0bfloat_value\x18\x03\x20\x01(\x02H\0R\nfloatValue\x12\
    #\n\x0cdouble_value\x18\x04\x20\x01(\x01H\0R\x0bdoubleValue\x12%\n\rbool\
    ean_value\x18\x05\x20\x01(\x08H\0R\x0cbooleanValue\x12#\n\x0cstring_valu\
    e\x18\x06\x20\x01(\tH\0R\x0bstringValue\x12x\n\x0fextension_value\x18\
    \x07\x20\x01(\x0b2M.org.eclipse.tahu.protobuf.Payload.DataSet.DataSetVal\
    ue.DataSetValueExtensionH\0R\x0eextensionValue\x1a!\n\x15DataSetValueExt\
    ension*\x08\x08\x01\x10\x80\x80\x80\x80\x02B\x07\n\x05value\x1ad\n\x03Ro\
    w\x12S\n\x08elements\x18\x01\x20\x03(\x0b27.org.eclipse.tahu.protobuf.Pa\
    yload.DataSet.DataSetValueR\x08elements*\x08\x08\x02\x10\x80\x80\x80\x80\
    \x02*\x08\x08\x05\x10\x80\x80\x80\x80\x02\x1a\xf5\x04\n\rPropertyValue\
    \x12\x12\n\x04type\x18\x01\x20\x01(\rR\x04type\x12\x17\n\x07is_null\x18\
    \x02\x20\x01(\x08R\x06isNull\x12\x1d\n\tint_value\x18\x03\x20\x01(\rH\0R\
    \x08intValue\x12\x1f\n\nlong_value\x18\x04\x20\x01(\x04H\0R\tlongValue\
    \x12!\n\x0bfloat_value\x18\x05\x20\x01(\x02H\0R\nfloatValue\x12#\n\x0cdo\
    uble_value\x18\x06\x20\x01(\x01H\0R\x0bdoubleValue\x12%\n\rboolean_value\
    \x18\x07\x20\x01(\x08H\0R\x0cbooleanValue\x12#\n\x0cstring_value\x18\x08\
    \x20\x01(\tH\0R\x0bstringValue\x12]\n\x11propertyset_value\x18\t\x20\x01\
    (\x0b2..org.eclipse.tahu.protobuf.Payload.PropertySetH\0R\x10propertyset\
    Value\x12c\n\x12propertysets_value\x18\n\x20\x01(\x0b22.org.eclipse.tahu\
    .protobuf.Payload.PropertySetListH\0R\x11propertysetsValue\x12r\n\x0fext\
    ension_value\x18\x0b\x20\x01(\x0b2G.org.eclipse.tahu.protobuf.Payload.Pr\
    opertyValue.PropertyValueExtensionH\0R\x0eextensionValue\x1a\"\n\x16Prop\
    ertyValueExtension*\x08\x08\x01\x10\x80\x80\x80\x80\x02B\x07\n\x05value\
    \x1au\n\x0bPropertySet\x12\x12\n\x04keys\x18\x01\x20\x03(\tR\x04keys\x12\
    H\n\x06values\x18\x02\x20\x03(\x0b20.org.eclipse.tahu.protobuf.Payload.P\
    ropertyValueR\x06values*\x08\x08\x03\x10\x80\x80\x80\x80\x02\x1am\n\x0fP\
    ropertySetList\x12P\n\x0bpropertyset\x18\x01\x20\x03(\x0b2..org.eclipse.\
    tahu.protobuf.Payload.PropertySetR\x0bpropertyset*\x08\x08\x02\x10\x80\
    \x80\x80\x80\x02\x1a\xef\x01\n\x08MetaData\x12\"\n\ris_multi_part\x18\
    \x01\x20\x01(\x08R\x0bisMultiPart\x12!\n\x0ccontent_type\x18\x02\x20\x01\
    (\tR\x0bcontentType\x12\x12\n\x04size\x18\x03\x20\x01(\x04R\x04size\x12\
    \x10\n\x03seq\x18\x04\x20\x01(\x04R\x03seq\x12\x1b\n\tfile_name\x18\x05\
    \x20\x01(\tR\x08fileName\x12\x1b\n\tfile_type\x18\x06\x20\x01(\tR\x08fil\
    eType\x12\x10\n\x03md5\x18\x07\x20\x01(\tR\x03md5\x12\x20\n\x0bdescripti\
    on\x18\x08\x20\x01(\tR\x0bdescription*\x08\x08\t\x10\x80\x80\x80\x80\x02\
    \x1a\x9c\x07\n\x06Metric\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x14\n\x05alias\x18\x02\x20\x01(\x04R\x05alias\x12\x1c\n\ttimestamp\
    \x18\x03\x20\x01(\x04R\ttimestamp\x12\x1a\n\x08datatype\x18\x04\x20\x01(\
    \rR\x08datatype\x12#\n\ris_historical\x18\x05\x20\x01(\x08R\x0cisHistori\
    cal\x12!\n\x0cis_transient\x18\x06\x20\x01(\x08R\x0bisTransient\x12\x17\
    \n\x07is_null\x18\x07\x20\x01(\x08R\x06isNull\x12G\n\x08metadata\x18\x08\
    \x20\x01(\x0b2+.org.eclipse.tahu.protobuf.Payload.MetaDataR\x08metadata\
    \x12N\n\nproperties\x18\t\x20\x01(\x0b2..org.eclipse.tahu.protobuf.Paylo\
    ad.PropertySetR\nproperties\x12\x1d\n\tint_value\x18\n\x20\x01(\rH\0R\
    \x08intValue\x12\x1f\n\nlong_value\x18\x0b\x20\x01(\x04H\0R\tlongValue\
    \x12!\n\x0bfloat_value\x18\x0c\x20\x01(\x02H\0R\nfloatValue\x12#\n\x0cdo\
    uble_value\x18\r\x20\x01(\x01H\0R\x0bdoubleValue\x12%\n\rboolean_value\
    \x18\x0e\x20\x01(\x08H\0R\x0cbooleanValue\x12#\n\x0cstring_value\x18\x0f\
    \x20\x01(\tH\0R\x0bstringValue\x12!\n\x0bbytes_value\x18\x10\x20\x01(\
    \x0cH\0R\nbytesValue\x12Q\n\rdataset_value\x18\x11\x20\x01(\x0b2*.org.ec\
    lipse.tahu.protobuf.Payload.DataSetH\0R\x0cdatasetValue\x12T\n\x0etempla\
    te_value\x18\x12\x20\x01(\x0b2+.org.eclipse.tahu.protobuf.Payload.Templa\
    teH\0R\rtemplateValue\x12i\n\x0fextension_value\x18\x13\x20\x01(\x0b2>.o\
    rg.eclipse.tahu.protobuf.Payload.Metric.MetricValueExtensionH\0R\x0eexte\
    nsionValue\x1a\x20\n\x14MetricValueExtension*\x08\x08\x01\x10\x80\x80\
    \x80\x80\x02B\x07\n\x05value*\x08\x08\x06\x10\x80\x80\x80\x80\x02*\xf2\
    \x03\n\x08DataType\x12\x0b\n\x07Unknown\x10\0\x12\x08\n\x04Int8\x10\x01\
    \x12\t\n\x05Int16\x10\x02\x12\t\n\x05Int32\x10\x03\x12\t\n\x05Int64\x10\
    \x04\x12\t\n\x05UInt8\x10\x05\x12\n\n\x06UInt16\x10\x06\x12\n\n\x06UInt3\
    2\x10\x07\x12\n\n\x06UInt64\x10\x08\x12\t\n\x05Float\x10\t\x12\n\n\x06Do\
    uble\x10\n\x12\x0b\n\x07Boolean\x10\x0b\x12\n\n\x06String\x10\x0c\x12\
    \x0c\n\x08DateTime\x10\r\x12\x08\n\x04Text\x10\x0e\x12\x08\n\x04UUID\x10\
    \x0f\x12\x0b\n\x07DataSet\x10\x10\x12\t\n\x05Bytes\x10\x11\x12\x08\n\x04\
    File\x10\x12\x12\x0c\n\x08Template\x10\x13\x12\x0f\n\x0bPropertySet\x10\
    \x14\x12\x13\n\x0fPropertySetList\x10\x15\x12\r\n\tInt8Array\x10\x16\x12\
    \x0e\n\nInt16Array\x10\x17\x12\x0e\n\nInt32Array\x10\x18\x12\x0e\n\nInt6\
    4Array\x10\x19\x12\x0e\n\nUInt8Array\x10\x1a\x12\x0f\n\x0bUInt16Array\
    \x10\x1b\x12\x0f\n\x0bUInt32Array\x10\x1c\x12\x0f\n\x0bUInt64Array\x10\
    \x1d\x12\x0e\n\nFloatArray\x10\x1e\x12\x0f\n\x0bDoubleArray\x10\x1f\x12\
    \x10\n\x0cBooleanArray\x10\x20\x12\x0f\n\x0bStringArray\x10!\x12\x11\n\r\
    DateTimeArray\x10\"B,\n\x19org.eclipse.tahu.protobufB\x0fSparkplugBProto\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
